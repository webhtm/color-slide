<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Color Sliding Game</title>
    <style>
        :root {
            --bg-color: #121212;
            --panel-color: #1e1e1e;
            --accent-color: #bb86fc;
            --text-color: #ffffff;
            --tile-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
        }

        body {
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            user-select: none;
        }

        h1 {
            margin-bottom: 5px;
            font-weight: 300;
            letter-spacing: 2px;
            text-transform: uppercase;
            color: var(--accent-color);
        }

        p.subtext {
            color: #888;
            font-size: 0.9rem;
            margin-bottom: 20px;
        }

        .stats-bar {
            display: flex;
            gap: 25px;
            margin-bottom: 20px;
            font-size: 1rem;
            color: #b0b0b0;
            background: rgba(255,255,255,0.05);
            padding: 10px 25px;
            border-radius: 50px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .stat-value {
            color: var(--accent-color);
            font-weight: bold;
            font-family: monospace;
            font-size: 1.2rem;
            margin-left: 5px;
        }

        #game-board {
            padding: 10px;
            background-color: var(--panel-color);
            border-radius: 12px;
            box-shadow: 0 20px 50px rgba(0,0,0,0.7);
            display: grid;
            gap: 6px;
            transition: all 0.3s ease; 
        }

        .block {
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 4px;
            cursor: pointer;
            position: relative;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.2);
            transition: transform 0.1s;
        }

        .block:not(.empty):active {
            transform: scale(0.95);
        }

        /* Using simpler colors without numbering so it feels less like "math" 
           and more like "sorting".
        */
        .color-0 { background: #cf6679; } /* Red */
        .color-1 { background: #03dac6; } /* Teal */
        .color-2 { background: #3700b3; } /* Deep Blue */
        .color-3 { background: #ffb74d; } /* Orange */
        .color-4 { background: #76ff03; } /* Lime */
        .color-5 { background: #b39ddb; } /* Lavender */

        .empty {
            background-color: transparent;
            cursor: default;
        }

        form {
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        select, button {
            background-color: var(--panel-color);
            color: white;
            border: 1px solid #333;
            padding: 8px 15px;
            border-radius: 6px;
            font-size: 0.9rem;
            cursor: pointer;
        }
        
        button {
            background-color: var(--accent-color);
            border: none;
            color: #000;
            font-weight: bold;
        }

        button:hover {
            filter: brightness(1.1);
        }

        /* Win Modal */
        #win-modal {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.85);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }
        #win-modal.show { display: flex; }
        #win-modal h2 { font-size: 3rem; margin: 0; color: var(--accent-color); }

    </style>
</head>
<body>

    <h1>Color Sliding Game</h1>
    <p class="subtext">Group same colors together. Any order works!</p>

    <form id="settings-form">
        <select id="grid-selector">
            <option value="3">3 x 3 (Easy)</option>
            <option value="4" selected>4 x 4 (Normal)</option>
            <option value="5">5 x 5 (Hard)</option>
        </select>
        <button type="submit">Restart</button>
    </form>

    <div class="stats-bar">
        <span>MOVES <span id="move-count" class="stat-value">0</span></span>
        <span>TIME <span id="time-count" class="stat-value">00:00</span></span>
    </div>

    <div id="game-board"></div>

    <div id="win-modal">
        <h2>SOLVED!</h2>
        <p>You grouped the colors successfully.</p>
        <button onclick="document.getElementById('win-modal').classList.remove('show'); initGame();">Play Again</button>
    </div>

    <script>
        let gridSize = 4;
        let blocks = []; 
        let emptyIndex = -1;
        let moves = 0;
        let timerInterval;
        let startTime;
        let isGameActive = false;

        const board = document.getElementById('game-board');
        const moveDisplay = document.getElementById('move-count');
        const timeDisplay = document.getElementById('time-count');
        const MAX_PALETTE = 6; 

        document.getElementById('settings-form').addEventListener('submit', (e) => {
            e.preventDefault();
            gridSize = parseInt(document.getElementById('grid-selector').value);
            initGame();
        });

        function initGame() {
            // Reset state
            isGameActive = true;
            moves = 0;
            updateStats();
            document.getElementById('win-modal').classList.remove('show');
            
            // Timer Reset
            clearInterval(timerInterval);
            timeDisplay.innerText = "00:00";
            startTime = Date.now();
            timerInterval = setInterval(updateTime, 1000);

            // Layout
            board.style.gridTemplateColumns = `repeat(${gridSize}, 1fr)`;
            board.style.gridTemplateRows = `repeat(${gridSize}, 1fr)`;
            const tileSize = gridSize > 4 ? 50 : 70;
            board.style.width = `${gridSize * tileSize + (gridSize * 6)}px`;
            board.style.height = `${gridSize * tileSize + (gridSize * 6)}px`;

            // 1. Create Blocks
            // We want chunks of colors.
            // E.g. for 4x4 (16 tiles), 15 colors. 
            // We can split into equal groups based on Grid Size.
            blocks = [];
            const totalPlayable = gridSize * gridSize - 1;
            
            // How many groups of colors? Let's match the row count.
            let colorsCount = gridSize; 
            if (colorsCount > MAX_PALETTE) colorsCount = MAX_PALETTE;

            for (let i = 0; i < totalPlayable; i++) {
                // Determine color based on even distribution
                // Math.floor(i / X) keeps adjacent items same color
                let colorId = Math.floor(i / (totalPlayable / colorsCount));
                
                // Cap it just in case
                if(colorId >= MAX_PALETTE) colorId = MAX_PALETTE - 1;
                
                blocks.push(colorId);
            }
            
            blocks.push('empty');
            emptyIndex = blocks.length - 1;

            // 2. Scramble
            scrambleBoard(gridSize * 30);
            renderBoard();
        }

        // Random Walk Scramble (Ensures solvability)
        function scrambleBoard(steps) {
            let lastPos = -1;
            for(let i=0; i<steps; i++) {
                let neighbors = getNeighbors(emptyIndex);
                // Avoid undoing the immediate last move for better mixing
                let valid = neighbors.filter(n => n !== lastPos);
                if(valid.length === 0) valid = neighbors;
                
                let target = valid[Math.floor(Math.random() * valid.length)];
                
                // Swap
                [blocks[emptyIndex], blocks[target]] = [blocks[target], blocks[emptyIndex]];
                lastPos = emptyIndex;
                emptyIndex = target;
            }
        }

        function getNeighbors(idx) {
            let n = [];
            let r = Math.floor(idx / gridSize);
            let c = idx % gridSize;
            
            if (r > 0) n.push(idx - gridSize); // Up
            if (r < gridSize - 1) n.push(idx + gridSize); // Down
            if (c > 0) n.push(idx - 1); // Left
            if (c < gridSize - 1) n.push(idx + 1); // Right
            return n;
        }

        function renderBoard() {
            board.innerHTML = '';
            blocks.forEach((val, index) => {
                const el = document.createElement('div');
                el.className = 'block';
                if (val === 'empty') {
                    el.classList.add('empty');
                } else {
                    el.classList.add(`color-${val}`);
                }
                el.onclick = () => handleMove(index);
                board.appendChild(el);
            });
        }

        function handleMove(index) {
            if (!isGameActive) return;
            const neighbors = getNeighbors(emptyIndex);
            
            if (neighbors.includes(index)) {
                // Swap
                [blocks[emptyIndex], blocks[index]] = [blocks[index], blocks[emptyIndex]];
                emptyIndex = index;
                
                moves++;
                updateStats();
                renderBoard();
                
                // Check win after tiny delay to allow UI to update
                setTimeout(checkAnyOrderWin, 20);
            }
        }

        // --- NEW LOGIC: ANY ORDER WIN ---
        function checkAnyOrderWin() {
            // 1. Convention: Puzzle is usually only "solved" if empty is at the end.
            if (blocks[blocks.length - 1] !== 'empty') return;

            // 2. Extract just the colors (remove 'empty')
            const tiles = blocks.filter(b => b !== 'empty');

            // 3. Check for Grouping.
            // A sorted list (in any order) means that once a color changes,
            // we should never see the previous color again.
            
            const seenColors = new Set();
            let lastColor = -1;

            for (let i = 0; i < tiles.length; i++) {
                const currentColor = tiles[i];

                if (i === 0) {
                    // Initialize
                    lastColor = currentColor;
                    seenColors.add(currentColor);
                    continue;
                }

                if (currentColor !== lastColor) {
                    // The color has switched!
                    // Check: Have we seen this new color before?
                    if (seenColors.has(currentColor)) {
                        // YES -> This means the groups are split up. 
                        // Example: Red, Blue, Red (Red was seen before, but we switched to Blue in middle)
                        return; // Not a win.
                    }
                    
                    // Register the new color
                    seenColors.add(currentColor);
                    lastColor = currentColor;
                }
            }

            // If we survived the loop, it means all groups are contiguous!
            gameWon();
        }

        function gameWon() {
            isGameActive = false;
            clearInterval(timerInterval);
            document.getElementById('win-modal').classList.add('show');
        }

        function updateStats() {
            moveDisplay.innerText = moves;
        }

        function updateTime() {
            const now = Date.now();
            const diff = Math.floor((now - startTime) / 1000);
            const m = Math.floor(diff / 60).toString().padStart(2, '0');
            const s = (diff % 60).toString().padStart(2, '0');
            timeDisplay.innerText = `${m}:${s}`;
        }

        window.onload = initGame;
    </script>
</body>
</html>
